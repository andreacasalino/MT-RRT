/**
 * Author:    Andrea Casalino
 * Created:   16.05.2019
 *
 * report any bug to andrecasa91@gmail.com.
 **/

#include <MT-RRT/ExtenderBidir.h>
#include <MT-RRT/ExtenderSingle.h>
#include <MT-RRT/ExtenderUtils.h>
#include <MT-RRT/LinkedTreesPlanner.h>

#include "MultiThreadedUtils.h"

#include <algorithm>
#include <math.h>
#include <omp.h>
#include <unordered_map>

namespace mt_rrt {
namespace {
// generated during the last batch of extensions
struct ExtensionsCache {
  using Rew =
      std::pair<Node *, std::vector<Rewire>>; // < new parent, involved >

  std::vector<Node *> nodes;
  std::vector<Rew> rewires;
};

// Allows to map nodes across trees
//
// Each node is assigned a FingerPrint that is <id of the tree that generated
// the node, index in the generating tree>.
// The only exception are roots, which are all assigned <0,0>
//
// This fingerprint allows to locate the node in the mainRegister and
// consequently find the counterpart of that node in any tree
class GlobalRegister {
public:
  GlobalRegister(const std::vector<Node *> &roots) { add(roots); }

  // locates twin of to_find, but in the tree handled by thread with id threadId
  Node *find(Node *to_find, std::size_t threadId) const {
    auto index = fingerPrints.find(to_find)->second;
    return mainRegister.find(index)->second[threadId];
  }

  void add(const std::vector<Node *> &nodes) {
    for (auto *node : nodes) {
      fingerPrints.emplace(node, fingerprintsCounter);
    }
    mainRegister[fingerprintsCounter++] = nodes;
  }

private:
  std::size_t fingerprintsCounter = 0;
  std::unordered_map<Node *, std::size_t> fingerPrints;
  std::unordered_map<std::size_t, std::vector<Node *>> mainRegister;
};

// generated by each tree while gathering the extensions results from all other
// ones
struct InternalizationCache {
  // <the node coming from an ExtensionsCache, the node actually internalized>
  std::unordered_map<Node *, Node *> mapping;
  std::vector<Node *> nodes_coming_from_this_tree;
};

struct NodeFinder {
  NodeFinder(std::size_t thId, InternalizationCache &cache,
             GlobalRegister &global)
      : thId{thId}, cache{cache}, global{global} {}

  Node *find(Node *to_find) const {
    if (auto it = cache.mapping.find(to_find); it != cache.mapping.end()) {
      return it->second;
    }
    return global.find(to_find, thId);
  }

private:
  std::size_t thId;
  InternalizationCache &cache;
  GlobalRegister &global;
};

class LinkedTreeHandler : public TreeHandlerBasic {
public:
  Node *internalize(const Node &subject) override {
    Node *added = this->TreeHandlerBasic::internalize(subject);
    extCache->nodes.push_back(added);
    return added;
  }

  void applyRewires(const Node &new_father,
                    const std::vector<Rewire> &rewires) override {
    this->TreeHandlerBasic::applyRewires(new_father, rewires);
    Node *parent = const_cast<Node *>(&new_father);
    extCache->rewires.emplace_back(std::make_pair(parent, rewires));
  }

  /////////////////////////////////////////////////////////////////////////////

  static std::vector<std::unique_ptr<LinkedTreeHandler>>
  make_trees(const View &root,
             const std::vector<ProblemDescriptionPtr> &problems,
             const Parameters &parameters) {
    std::vector<std::unique_ptr<LinkedTreeHandler>> res;
    std::vector<Node *> roots;
    for (std::size_t th_id = 0; th_id < problems.size(); ++th_id) {
      res.emplace_back().reset(
          new LinkedTreeHandler(root, problems[th_id], parameters, th_id));
      roots.push_back(res.back()->nodes.front());
    }
    auto allTrees = std::make_shared<std::vector<LinkedTreeHandler *>>();
    for (const auto &tree : res) {
      allTrees->push_back(tree.get());
    }
    auto sharedRegister = std::make_shared<GlobalRegister>(roots);
    for (auto &tree : res) {
      tree->sharedRegister = sharedRegister;
      tree->allTrees = allTrees;
    }
    return res;
  }

  void resetExtensionCache() { extCache.emplace(); }

  void internalizeResults() {
    intCache.emplace();
    intCache->nodes_coming_from_this_tree = extCache->nodes;
    for (auto *added : extCache->nodes) {
      intCache->mapping.emplace(added, added);
    }
    for (auto *hndlr : *allTrees) {
      if (hndlr == this)
        continue;
      NodeFinder finder{threadId, intCache.value(), *sharedRegister};
      // internalize explored nodes
      std::size_t nodes_start = nodes.size();
      for (auto *toAdd : hndlr->extCache->nodes) {
        auto &added = allocator.emplace_back(toAdd->state());
        nodes.push_back(&added);
        intCache->mapping.emplace(toAdd, &added);
        added.setParent(*toAdd->getParent(), toAdd->cost2Go());
      }
      std::for_each(nodes.begin() + nodes_start, nodes.end(), [&](Node *n) {
        Node *parent = finder.find(const_cast<Node *>(n->getParent()));
        n->setParent(*parent, n->cost2Go());
      });
      // internalize rewires
      for (auto &[parent, rew] : hndlr->extCache->rewires) {
        std::vector<Rewire> trsfm_rewires;
        for (auto [involved, cost] : rew) {
          trsfm_rewires.emplace_back(Rewire{finder.find(involved), cost});
        }
        apply_rewires_if_better(*finder.find(parent), trsfm_rewires);
      }
    }
  }

  void updateGlobalRegister() {
    std::vector<Node *> twins;
    twins.resize(allTrees->size());
    for (auto *tree : *allTrees) {
      for (auto *node : tree->intCache->nodes_coming_from_this_tree) {
        std::size_t k = 0;
        for (auto *handler : *allTrees) {
          Node *n = handler == tree
                        ? node
                        : handler->intCache->mapping.find(node)->second;
          twins[k++] = n;
        }
        sharedRegister->add(twins);
      }
    }
  }

private:
  LinkedTreeHandler(const View &root, const ProblemDescriptionPtr &problem,
                    const Parameters &parameters, std::size_t th_id)
      : TreeHandlerBasic(root, problem, parameters), threadId{th_id} {}

  std::size_t threadId;
  std::shared_ptr<std::vector<LinkedTreeHandler *>> allTrees;
  std::optional<ExtensionsCache> extCache;
  std::optional<InternalizationCache> intCache;
  std::shared_ptr<GlobalRegister> sharedRegister;
};

template <typename Pred>
void for_each_handler(const std::vector<LinkedTreeHandler *> &handlers,
                      Pred &&pred) {
  for (std::size_t h = omp_get_thread_num(); h < handlers.size();
       h += omp_get_num_threads()) {
    pred(*handlers[h]);
  }
}
} // namespace

void LinkedTreesPlanner::solve_(const std::vector<float> &start,
                                const std::vector<float> &end,
                                const Parameters &parameters,
                                PlannerSolution &recipient) {
  resizeDescriptions(getThreads());
  Extenders extenders;
  std::vector<LinkedTreeHandler *> handlers;

  auto batched_iterations = compute_batched_iterations(
      parameters.iterations, getThreads(), synchronization());

  auto batch_iter_parameters = parameters;
  batch_iter_parameters.iterations.set(batched_iterations);

  switch (parameters.expansion_strategy) {
  case ExpansionStrategy::Single:
  case ExpansionStrategy::Star: {
    for (auto &&tree : LinkedTreeHandler::make_trees(
             start, getAllDescriptions(), batch_iter_parameters)) {
      handlers.push_back(tree.get());
      extenders.emplace_back(
          std::make_unique<ExtenderSingle>(std::move(tree), end));
    }
  } break;
  case ExpansionStrategy::Bidir: {
    auto front_trees = LinkedTreeHandler::make_trees(
        start, getAllDescriptions(), batch_iter_parameters);
    for (const auto &tree : front_trees) {
      handlers.push_back(tree.get());
    }
    auto back_trees = LinkedTreeHandler::make_trees(end, getAllDescriptions(),
                                                    batch_iter_parameters);
    for (const auto &tree : back_trees) {
      handlers.push_back(tree.get());
    }
    for (std::size_t k = 0; k < front_trees.size(); ++k) {
      extenders.emplace_back(std::make_unique<ExtenderBidirectional>(
          std::move(front_trees[k]), std::move(back_trees[k])));
    }
  } break;
  }

  std::atomic<std::size_t> iter = 0;
  KeepSearchPredicate search_predicate{parameters.best_effort,
                                       parameters.iterations.get(),
                                       parameters.expansion_strategy};

  parallel_region(getThreads(), [&]() {
    Extender &extender = *extenders[omp_get_thread_num()];
    while (search_predicate(iter)) {
      for_each_handler(handlers, [](LinkedTreeHandler &hndlr) {
        hndlr.resetExtensionCache();
      });
      iter += extender.search();
      if (!extender.getSolutions().empty()) {
        search_predicate.one_solution_was_found = true;
      }
#pragma omp barrier
      for_each_handler(handlers, [](LinkedTreeHandler &hndlr) {
        hndlr.internalizeResults();
      });
#pragma omp barrier
      if (omp_get_thread_num() != 0)
        continue;
      for_each_handler(handlers, [](LinkedTreeHandler &hndlr) {
        hndlr.updateGlobalRegister();
      });
    }
  });

  recipient.iterations = iter;
  recipient.solution = get_best_solution(extenders);
  emplace_trees(recipient, extenders);
}
} // namespace mt_rrt
