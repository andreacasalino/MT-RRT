%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% The following packages can be found on http:\\www.ctan.org
\usepackage{cite}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{times}
\usepackage{latexsym}
\usepackage{psfrag}
\usepackage[dvips]{epsfig}
%\graphicspath{{./images/eps/}}
\DeclareGraphicsExtensions{.eps,.ps}
%\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{theorem}
\interdisplaylinepenalty=2500
\usepackage{array}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{tikz}
\usepackage{bm}
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage[bottom]{footmisc}
\algtext*{EndIf}% Remove "end if" text


\raggedbottom

\title{\LARGE \bf
MT-RRT: a general purpose multithreading library for path planning
%Parallelizing the RRT algorithms with multithreading strategies
}


\author{Andrea Casalino$^{1}$,  Andrea Maria Zanchettin$^{1}$ and Paolo Rocco$^{1}$% <-this % stops a space
\thanks{ $^{1}$ The authors are with Politecnico di Milano, Dipartimento di
Elettronica, Informazione e Bioingegneria, Piazza L. Da Vinci 32,
20133, Milano, Italy (e-mail: name.surname@polimi.it).}%
}


\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Rapidly Random exploring Trees are popular algorithms in the field of motion planning.
A feasible path connecting two different poses is found by incrementally building a tree data structure. They are powerful and flexible, but also computationally intense, requiring thousands of iterations before their termination. 
The aim of this article is to show the capabilities of MT-RRT, a general purpose library which exploits four different multithreading strategies to speed up the planning process of Rapidly Random exploring Trees.
The performance achieved by MT-RRT are verified on various benchmarks, providing general results valid for a great class of planning problems.
The strategies proposed are able to significantly reduce the computation time absorbed by the planning process.
\end{abstract}


\section{Introduction}\label{sec:intro}

Path planning is one of the most classical problems in robotics. 
Essentially, the problem consists in finding a feasible trajectory leading a manipulator, or more in general a dynamical system, from a starting state to an ending desired one.
%It consists in driving an articulated mechanism, from an initial configuration to a desired ending one, while considering a series of constraints: for example avoiding some obstacles populating the workspace or taking into account some prescriptions about the end effector orientation.
Some planners obtain the solution step-by-step, as the result of a closed-loop control scheme.
Such algorithms are typically designed for on-line implementations.
Examples are the approaches based on repulsive field \cite{Khatib_repulsive}, \cite{Rimon_repulsive}: a motion for the robot is obtained by applying some virtual forces, generated by the obstacles populating the scene.  
Such methods are typically affected by local minima problems, leading the robot to some equilibrium point far from the desired ending configuration.
MPC approaches like \cite{MPC_01} or \cite{MPC_02} are other examples of closed-loop approaches.
Generally, these methods are not computationally intense but fail to find a solution for those problems having a complex shaped admitted region. 
\\
On the opposite, other classes of planners are designed to be deployed off-line, computing in a single step an entire trajectory solving the planning problem.
Rapidly Random exploring Trees (RRT) \cite{RRT_LaValle} are the most representative example.
They explore the admitted space in an incremental way, building a search tree. They are more computationally demanding, but they are able to find feasible paths also for those problems characterized by very cluttered environments. 
With respect to the original formulation proposed in \cite{RRT_LaValle}, many variants have been proposed to improve the searching process. For example, \cite{RC_RRT} proposed a reducing metric sensitivity to promote the expansion of the tree, starting from those nodes resulting far from the obstacles, in order to obtain in a faster way the solution. 
\cite{RRT_narrow} proposed a version specifically designed to find feasible trajectories passing through narrow passages.
RRT were also proved to be deployable as kinodynamic planners, designing optimal LQR controller driving a generic dynamical system to a desired final state, see \cite{LQR_RRT_01} and  
\cite{LQR_RRT_02}.
\\
On the other hand, all the planners proposed, even for medium-complex problems, require thousands of iterations to obtain a solution. 
Therefore, multithreading strategies can be deployed to speed up any kind of planning problem.
In particular, the aim of this article is to show the capabilities of MT-RRT: a general purpose path planning library, which exploits four different possible multithreading strategies for parallelizing RRT algorithms. 
\\
Some parallel computation strategies for this kind of planning algorithms were already proposed, even though the related literature is not rich.
A review of this topic, addressing not only RRTs, can be found in \cite{Planning_parall_review}.
\cite{RRT_GPU} uses GPU to parallelize only the collision check phase, even though this activity might not be the most time consuming one. 
\cite{RRT_MPI} made use of a distributed memory approach, proposing some multi-processing strategies. Processes are coordinated via message-passing, resulting in augmented overheads in comparison to the multithreading strategies proposed here.  
\\
To the best of the authors' knowledge, it is difficult to find works reporting general results, valid for any kind of planning problems. In this work, the performance achievable by MT-RRT will be tested in many different planning scenarios, showing the scalability with respect to the number of employed threads. Such scenarios are representative of a great class of planning problems, providing general results about which kind of strategy is more indicated to speed up a particular class of planning problems. 
\\
The rest of this article is structured as follows:
Section \ref{sec:cap_02} will briefly review the basic mechanism of the RRT algorithms; while Section \ref{sec:cap_03} will describe four different strategies for parallelizing them, whose performance are reported in Section \ref{sec:cap_04}.
Section \ref{sec:conclusion} will provide a discussion of the achieved performance.


%Stato arte su Parallel RRT, considerando articoli trovati.
%Spiegare che in generale algoritmi RRT sono difficilmente parallelizzabili e perchè.

%Parlare di alternativa possibile per path planning che sfrutta calcolo parallelo che è rappresentata da dynamic road map: uso parall comp per escludere velocemente gli edge non più validi. 

\section{Background on RRT algorithms}
\label{sec:cap_02}
\input{cap_02.tex}

\section{MT-RRT strategies}
\label{sec:cap_03}
\input{cap_03.tex}

%\section{Multiprocess strategies}
%\input{cap_04_old.tex}


\section{Performance analysis}
\label{sec:cap_04}
\input{cap_04.tex}


\section{Conclusions}
\label{sec:conclusion}

The strategy presented in Section \ref{subsec:MT_01} results to be effective for Problem 3, i.e. the scenario for which $T_{\tau}  \gg T_V$, while for all the other problems its performance result to be poor in comparison to the other approaches. The reason is the presence of severe overhead times: after every collective search of the Nearest Neighbour or the determination of a Near set, threads must wait for all the others to end that search. Moreover, this happens at every iteration.
\\
The strategies reported in Sections \ref{subsec:MT_02} and \ref{subsec:MT_03} achieve comparable performance when considering the classical RRT and its bidirectional version, while for RRT* the approach presented in Section \ref{subsec:MT_03} outperforms the one of Section \ref{subsec:MT_02}. The reason is the presence of the critical regions for applying rewirds, which leads to time waste. 
\\
The multi agent approach of Section \ref{subsec:MT_04} is significantly faster w.r.t all the other methods for all the RRT versions considered, because threads perform parallel extensions on reduced-size trees. 
However, when considering the RRT* algorithm, the approach in \ref{subsec:MT_04} is an approximation of the canonical version, that might lead to solutions that are near-optimal. Therefore, for those cases for which the optimality is crucial, the approach of Section \ref{subsec:MT_03} can be efficiently deployed.
The entire MT-RRT library is available at \cite{github_link}, which contains also detailed directions to derive a customized planning problem to be solved with the usage of MT-RRT.
%\\
%It could be interesting for future studies to extend the proposed techniques for multi processing environments. Such approaches would achieve for sure slower computation times (because results must be communicate between threads because sharing memory it is not possible), but could be the only exploitable way for parallelizing an RRT problem when using different machines with their one processors and memory storage, with however a much bigger number of concurrent processes.



\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,bibliografia}

\end{document}
