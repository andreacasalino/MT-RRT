<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MT_RRT, the general purpose multi threading library for RRT.: MT_RTT::Node::I_Node_factory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MT_RRT, the general purpose multi threading library for RRT.
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_m_t___r_t_t.html">MT_RTT</a></li><li class="navelem"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a></li><li class="navelem"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MT_RTT::Node::I_Node_factory Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for the class describing the particular planning problem to solve.  
 <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_problem__description_8h_source.html">Problem_description.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MT_RTT::Node::I_Node_factory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.png" usemap="#MT_5FRTT::Node::I_5FNode_5Ffactory_map" alt=""/>
  <map id="MT_5FRTT::Node::I_5FNode_5Ffactory_map" name="MT_5FRTT::Node::I_5FNode_5Ffactory_map">
<area href="class_m_t___r_t_t_1_1_i___node__factory__decorator.html" title="Interface for the generic I_Node_factory decorator." alt="MT_RTT::I_Node_factory_decorator" shape="rect" coords="0,56,226,80"/>
<area href="class_m_t___r_t_t_1_1_node__factory__concrete.html" title="Each handler describing a real planning problem must be derived from this class." alt="MT_RTT::Node_factory_concrete" shape="rect" coords="236,56,462,80"/>
<area href="class_m_t___r_t_t_1_1_node__factory__multiple__steer.html" title="Used for performing each steer operation multiple times, trying to reach faster the target node." alt="MT_RTT::Node_factory_multiple_steer" shape="rect" coords="0,112,226,136"/>
<area href="class_m_t___r_t_t_1_1_manipulator__path__handler.html" title="Interface for handling classical path planning problem of a single or a group of articulated fixed ro..." alt="MT_RTT::Manipulator_path_handler" shape="rect" coords="236,112,462,136"/>
<area href="class_m_t___r_t_t_1_1_bubbles__free__configuration.html" title="In this object, the steering is done considering bubbles of free configuration, Section 2...." alt="MT_RTT::Bubbles_free_configuration" shape="rect" coords="118,168,344,192"/>
<area href="class_m_t___r_t_t_1_1_tunneled__check__collision.html" title="In this object, the collision along a certain segment in the configurational space (i...." alt="MT_RTT::Tunneled_check_collision" shape="rect" coords="354,168,580,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac400f20abadc07b9babc63eea56a7282"><td class="memItemLeft" align="right" valign="top"><a id="ac400f20abadc07b9babc63eea56a7282"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>I_Node_factory</b> (const <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a> &amp;o)=delete</td></tr>
<tr class="separator:ac400f20abadc07b9babc63eea56a7282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff670926bead9518c5b67295fe178fab"><td class="memItemLeft" align="right" valign="top"><a id="aff670926bead9518c5b67295fe178fab"></a>
<a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a> &amp;o)=delete</td></tr>
<tr class="separator:aff670926bead9518c5b67295fe178fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05f0d7d05d75033c8874a83a118d98a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ac05f0d7d05d75033c8874a83a118d98a">Random_node</a> ()</td></tr>
<tr class="memdesc:ac05f0d7d05d75033c8874a83a118d98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a node having a state randomly sampled in the \mathcal{X} space, Section 1.2.1 of the documentation.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ac05f0d7d05d75033c8874a83a118d98a">More...</a><br /></td></tr>
<tr class="separator:ac05f0d7d05d75033c8874a83a118d98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032006307a2de0af57f1c02cd0c44df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a032006307a2de0af57f1c02cd0c44df1">Cost_to_go</a> (float *result, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *start, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *ending_node)</td></tr>
<tr class="memdesc:a032006307a2de0af57f1c02cd0c44df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the cost C(\tau), Section 1.2.3 of the documentation, of the trajectory \tau going from the starting node to the ending one, for two nodes not already connected.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a032006307a2de0af57f1c02cd0c44df1">More...</a><br /></td></tr>
<tr class="separator:a032006307a2de0af57f1c02cd0c44df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795eb5651df7246806d8a6188eb3809d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a795eb5651df7246806d8a6188eb3809d">Cost_to_go_constraints</a> (float *result, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *start, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *trg)</td></tr>
<tr class="memdesc:a795eb5651df7246806d8a6188eb3809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the constrained cost of the trajectory going from the starting node to the ending one, for two nodes not already connected.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a795eb5651df7246806d8a6188eb3809d">More...</a><br /></td></tr>
<tr class="separator:a795eb5651df7246806d8a6188eb3809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e13935a7793bcff0939b43195a460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a0f2e13935a7793bcff0939b43195a460">Steer</a> (<a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *start, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *trg, bool *trg_reached)</td></tr>
<tr class="memdesc:a0f2e13935a7793bcff0939b43195a460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a steering operation, Section 1.2.1 of the documentation, from a staring node to a target one.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a0f2e13935a7793bcff0939b43195a460">More...</a><br /></td></tr>
<tr class="separator:a0f2e13935a7793bcff0939b43195a460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07c0cc5f12c85dfa5ca3717e829c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a8f07c0cc5f12c85dfa5ca3717e829c3d">Clone_Node</a> (const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> &amp;o)</td></tr>
<tr class="memdesc:a8f07c0cc5f12c85dfa5ca3717e829c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a node with the same state and father of the node passed as input.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a8f07c0cc5f12c85dfa5ca3717e829c3d">More...</a><br /></td></tr>
<tr class="separator:a8f07c0cc5f12c85dfa5ca3717e829c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f059959d7413fcd9b8f719fb380ea1"><td class="memItemLeft" align="right" valign="top"><a id="a94f059959d7413fcd9b8f719fb380ea1"></a>
virtual const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a94f059959d7413fcd9b8f719fb380ea1">Get_State_size</a> () const =0</td></tr>
<tr class="memdesc:a94f059959d7413fcd9b8f719fb380ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cardinality of \mathcal{X}, Section 1.2.1 of the documentation, of the plannig problem handled by this object. <br /></td></tr>
<tr class="separator:a94f059959d7413fcd9b8f719fb380ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603ab906bbe3b867ad6e902d65c92508"><td class="memItemLeft" align="right" valign="top"><a id="a603ab906bbe3b867ad6e902d65c92508"></a>
virtual const float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a603ab906bbe3b867ad6e902d65c92508">Get_Gamma</a> () const =0</td></tr>
<tr class="memdesc:a603ab906bbe3b867ad6e902d65c92508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the \gamma parameter, Section 1.2.3 of the documentation, regulating the near set size, that RRT* versions must compute. <br /></td></tr>
<tr class="separator:a603ab906bbe3b867ad6e902d65c92508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b515a5b23df01e30a59a940de6fffe5"><td class="memItemLeft" align="right" valign="top"><a id="a6b515a5b23df01e30a59a940de6fffe5"></a>
virtual const bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a6b515a5b23df01e30a59a940de6fffe5">Get_symm_flag</a> () const =0</td></tr>
<tr class="memdesc:a6b515a5b23df01e30a59a940de6fffe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true in case the planning problem handled by this object is symmetric, i.e. the cost to go from a node A to B is the same of the cost to go from B to A. <br /></td></tr>
<tr class="separator:a6b515a5b23df01e30a59a940de6fffe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3f419dc15cdedb4640d8818edc080c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ade3f419dc15cdedb4640d8818edc080c">New_root</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;state)</td></tr>
<tr class="memdesc:ade3f419dc15cdedb4640d8818edc080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a new root for a tree.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ade3f419dc15cdedb4640d8818edc080c">More...</a><br /></td></tr>
<tr class="separator:ade3f419dc15cdedb4640d8818edc080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d9a5a09eee6dba95f2e671ac47677c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ae5d9a5a09eee6dba95f2e671ac47677c">copy</a> ()=0</td></tr>
<tr class="memdesc:ae5d9a5a09eee6dba95f2e671ac47677c"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for cloning this object: a deep copy must be implemented.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ae5d9a5a09eee6dba95f2e671ac47677c">More...</a><br /></td></tr>
<tr class="separator:ae5d9a5a09eee6dba95f2e671ac47677c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd3239714320a3b1ebaa18cc4eb62b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#aefd3239714320a3b1ebaa18cc4eb62b3">Random_node</a> (float *random_state)=0</td></tr>
<tr class="memdesc:aefd3239714320a3b1ebaa18cc4eb62b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ac05f0d7d05d75033c8874a83a118d98a" title="Returns a node having a state randomly sampled in the \mathcal{X} space, Section 1....">I_Node_factory::Random_node()</a>.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#aefd3239714320a3b1ebaa18cc4eb62b3">More...</a><br /></td></tr>
<tr class="separator:aefd3239714320a3b1ebaa18cc4eb62b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a654030645bd6b187e59bd25a696893"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a1a654030645bd6b187e59bd25a696893">Cost_to_go</a> (float *result, const float *start_state, const float *ending_state)=0</td></tr>
<tr class="memdesc:a1a654030645bd6b187e59bd25a696893"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a032006307a2de0af57f1c02cd0c44df1" title="Evaluates the cost C(\tau), Section 1.2.3 of the documentation, of the trajectory \tau going from the...">I_Node_factory::Cost_to_go(float* result, const Node* start, const  Node* trg)</a>.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a1a654030645bd6b187e59bd25a696893">More...</a><br /></td></tr>
<tr class="separator:a1a654030645bd6b187e59bd25a696893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333bb3df2390834f118bda25eccc44ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a333bb3df2390834f118bda25eccc44ee">Cost_to_go_constraints</a> (float *result, const float *start_state, const float *ending_state)=0</td></tr>
<tr class="memdesc:a333bb3df2390834f118bda25eccc44ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a795eb5651df7246806d8a6188eb3809d" title="Evaluates the constrained cost of the trajectory going from the starting node to the ending one,...">I_Node_factory::Cost_to_go_constraints(float* result, const Node* start, const  Node* trg)</a>.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a333bb3df2390834f118bda25eccc44ee">More...</a><br /></td></tr>
<tr class="separator:a333bb3df2390834f118bda25eccc44ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e113e0973917cb82d2cef5988e5cd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#aad2e113e0973917cb82d2cef5988e5cd">Steer</a> (float *cost_steered, float *steered_state, const float *start_state, const float *target_state, bool *trg_reached)=0</td></tr>
<tr class="memdesc:aad2e113e0973917cb82d2cef5988e5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a0f2e13935a7793bcff0939b43195a460" title="Performs a steering operation, Section 1.2.1 of the documentation, from a staring node to a target on...">I_Node_factory::Steer(Node* start, const  Node* trg, bool* trg_reached)</a>.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#aad2e113e0973917cb82d2cef5988e5cd">More...</a><br /></td></tr>
<tr class="separator:aad2e113e0973917cb82d2cef5988e5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a83036622e3c4277ff6c57b18430b8f"><td class="memItemLeft" align="right" valign="top"><a id="a5a83036622e3c4277ff6c57b18430b8f"></a>
float *&#160;</td><td class="memItemRight" valign="bottom"><b>Alloc_state</b> ()</td></tr>
<tr class="separator:a5a83036622e3c4277ff6c57b18430b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for the class describing the particular planning problem to solve. </p>
<p>It is crucial for addressing step A of the pipeline presented in Section 1.3 of the documentation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8f07c0cc5f12c85dfa5ca3717e829c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f07c0cc5f12c85dfa5ca3717e829c3d">&#9670;&nbsp;</a></span>Clone_Node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> MT_RTT::Node::I_Node_factory::Clone_Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a node with the same state and father of the node passed as input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the cloned node (the result is returned by internally using move: it is not copied). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>the node to clone </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d9a5a09eee6dba95f2e671ac47677c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d9a5a09eee6dba95f2e671ac47677c">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a>&gt; MT_RTT::Node::I_Node_factory::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for cloning this object: a deep copy must be implemented. </p>
<p>This function is invoked by parallel planners for dispatching copies of this class to the other working threads. In this way, the threads must not be forced to synchronize for accessing the methods of an <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html" title="Interface for the class describing the particular planning problem to solve.">I_Node_factory</a>. Therefore, when deriving your own factory describing your own problem, be carefull to avoid shallow copies and implement deep copies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>a clone of this object </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_t___r_t_t_1_1_node__factory__multiple__steer.html#a30feb56feba944a59059461806afee45">MT_RTT::Node_factory_multiple_steer</a>, <a class="el" href="class_m_t___r_t_t_1_1_bubbles__free__configuration.html#ae8d46dd3996e2c41a8bc297128325f06">MT_RTT::Bubbles_free_configuration</a>, and <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aa098f274f2ca2b2ec24ef2364dbe15a3">MT_RTT::Tunneled_check_collision</a>.</p>

</div>
</div>
<a id="a1a654030645bd6b187e59bd25a696893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a654030645bd6b187e59bd25a696893">&#9670;&nbsp;</a></span>Cost_to_go() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MT_RTT::Node::I_Node_factory::Cost_to_go </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>start_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ending_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a032006307a2de0af57f1c02cd0c44df1" title="Evaluates the cost C(\tau), Section 1.2.3 of the documentation, of the trajectory \tau going from the...">I_Node_factory::Cost_to_go(float* result, const Node* start, const  Node* trg)</a>. </p>
<p>This is function is actually in charge of computing C( \tau_{start -&gt; ending_node} ), considering the passed start_state and ending_state, which are array of values describing the staring and the ending state to consider. </p>

<p>Implemented in <a class="el" href="class_m_t___r_t_t_1_1_i___node__factory__decorator.html#ad8137fdbff3df60d3e4f83738238050f">MT_RTT::I_Node_factory_decorator</a>, and <a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#a7d2cf22ed955fb79d13b2a4c15ab5dc1">MT_RTT::Manipulator_path_handler</a>.</p>

</div>
</div>
<a id="a032006307a2de0af57f1c02cd0c44df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032006307a2de0af57f1c02cd0c44df1">&#9670;&nbsp;</a></span>Cost_to_go() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::Node::I_Node_factory::Cost_to_go </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>ending_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the cost C(\tau), Section 1.2.3 of the documentation, of the trajectory \tau going from the starting node to the ending one, for two nodes not already connected. </p>
<p>This cost doesn't account for constraints, but considers only the optimal unconstrained trajectory \tau leading from the starting to the ending node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>the computed cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>the starting node in the trajectory whose cost is to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ending_node</td><td>the ending node in the trajectory whose cost is to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a333bb3df2390834f118bda25eccc44ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333bb3df2390834f118bda25eccc44ee">&#9670;&nbsp;</a></span>Cost_to_go_constraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MT_RTT::Node::I_Node_factory::Cost_to_go_constraints </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>start_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ending_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a795eb5651df7246806d8a6188eb3809d" title="Evaluates the constrained cost of the trajectory going from the starting node to the ending one,...">I_Node_factory::Cost_to_go_constraints(float* result, const Node* start, const  Node* trg)</a>. </p>
<p>This function is actually in charge of computing max{ C( \tau_{start -&gt; ending_node} ) , C_adm}, considering the passed start_state and ending_state, which are array of values describing the staring and the ending state to consider. </p>

<p>Implemented in <a class="el" href="class_m_t___r_t_t_1_1_i___node__factory__decorator.html#a7beed62db24a5eaa3627f639ec8709f2">MT_RTT::I_Node_factory_decorator</a>, <a class="el" href="class_m_t___r_t_t_1_1_bubbles__free__configuration.html#a345f0bb0982d1bd606c615602737694c">MT_RTT::Bubbles_free_configuration</a>, and <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aa004c87d71129d0bbf14898e4544062e">MT_RTT::Tunneled_check_collision</a>.</p>

</div>
</div>
<a id="a795eb5651df7246806d8a6188eb3809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795eb5651df7246806d8a6188eb3809d">&#9670;&nbsp;</a></span>Cost_to_go_constraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::Node::I_Node_factory::Cost_to_go_constraints </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>trg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the constrained cost of the trajectory going from the starting node to the ending one, for two nodes not already connected. </p>
<p>This cost accounts for constraints. In case the constraints are violated along the nominal trajectory going from the starting node to the ending one, a FLT_MAX is returned. Otherwise, the cost returned is the one of the nominal trajectory, i.e. the one computed with <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a032006307a2de0af57f1c02cd0c44df1" title="Evaluates the cost C(\tau), Section 1.2.3 of the documentation, of the trajectory \tau going from the...">I_Node_factory::Cost_to_go</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>the computed cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>the starting node in the trajectory whose cost is to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ending_node</td><td>the ending node in the trajectory whose cost is to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade3f419dc15cdedb4640d8818edc080c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3f419dc15cdedb4640d8818edc080c">&#9670;&nbsp;</a></span>New_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> MT_RTT::Node::I_Node_factory::New_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a new root for a tree. </p>
<p>The root is a node having a NULL father. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>the state that will be contained in the root to create. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the created root (the result is returned by internally using move: it is not copied). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac05f0d7d05d75033c8874a83a118d98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05f0d7d05d75033c8874a83a118d98a">&#9670;&nbsp;</a></span>Random_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> MT_RTT::Node::I_Node_factory::Random_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a node having a state randomly sampled in the \mathcal{X} space, Section 1.2.1 of the documentation. </p>
<p>This function is invoked for randomly growing a searching tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the random node computed (the result is returned by internally using move: it is not copied). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefd3239714320a3b1ebaa18cc4eb62b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd3239714320a3b1ebaa18cc4eb62b3">&#9670;&nbsp;</a></span>Random_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MT_RTT::Node::I_Node_factory::Random_node </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>random_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ac05f0d7d05d75033c8874a83a118d98a" title="Returns a node having a state randomly sampled in the \mathcal{X} space, Section 1....">I_Node_factory::Random_node()</a>. </p>
<p>The passed random_state is an array of values already with the cardinality of \mathcal{X}, which must be set to random values by this function. </p>

<p>Implemented in <a class="el" href="class_m_t___r_t_t_1_1_i___node__factory__decorator.html#aa72073d5a0dadaa15acfeff4b4a59372">MT_RTT::I_Node_factory_decorator</a>, and <a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#aa1d0c75bb794a9b2ae872be9caf56216">MT_RTT::Manipulator_path_handler</a>.</p>

</div>
</div>
<a id="aad2e113e0973917cb82d2cef5988e5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2e113e0973917cb82d2cef5988e5cd">&#9670;&nbsp;</a></span>Steer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MT_RTT::Node::I_Node_factory::Steer </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>cost_steered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>steered_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>start_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>target_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>trg_reached</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally called by <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a0f2e13935a7793bcff0939b43195a460" title="Performs a steering operation, Section 1.2.1 of the documentation, from a staring node to a target on...">I_Node_factory::Steer(Node* start, const  Node* trg, bool* trg_reached)</a>. </p>
<p>This function is actually in charge of performing the steering operation, considering the passed start_state and target_state, which are array of values describing the starting and target state to consider. cost_steered must be returned equal to NULL in case the steering was not possible. </p>

<p>Implemented in <a class="el" href="class_m_t___r_t_t_1_1_node__factory__multiple__steer.html#aedb3d4d1a9999125256566d1e95b1002">MT_RTT::Node_factory_multiple_steer</a>, <a class="el" href="class_m_t___r_t_t_1_1_i___node__factory__decorator.html#a15e3d39429bf72912a5b5887027e897f">MT_RTT::I_Node_factory_decorator</a>, <a class="el" href="class_m_t___r_t_t_1_1_bubbles__free__configuration.html#a8cbc7c85c962ca7571054e0e2d786517">MT_RTT::Bubbles_free_configuration</a>, and <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aeb241415099150bb9846aec2b1848385">MT_RTT::Tunneled_check_collision</a>.</p>

</div>
</div>
<a id="a0f2e13935a7793bcff0939b43195a460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2e13935a7793bcff0939b43195a460">&#9670;&nbsp;</a></span>Steer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> MT_RTT::Node::I_Node_factory::Steer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>trg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>trg_reached</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a steering operation, Section 1.2.1 of the documentation, from a staring node to a target one. </p>
<p>The node returned contains the steered state. In case a steering operation is not possible, a <a class="el" href="class_m_t___r_t_t_1_1_node.html" title="Used internally by a tree (see Tree.h) for representing a state x \in \underline{\mathcal{X}},...">Node</a> with a NULL State is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the node with the steered configuration (the result is returned by internally using move: it is not copied). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>the starting node from which the steer operation must be tried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trg</td><td>the target node to which the steer operation must be tried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">trg_reached</td><td>returns true in case the steering was possible and led to reach the target node. Otherwise false is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Header/<a class="el" href="_problem__description_8h_source.html">Problem_description.h</a></li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Problem_description.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
