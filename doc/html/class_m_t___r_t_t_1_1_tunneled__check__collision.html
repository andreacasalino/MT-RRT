<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MT_RRT, the general purpose multi threading library for RRT.: MT_RTT::Tunneled_check_collision Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MT_RRT, the general purpose multi threading library for RRT.
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_m_t___r_t_t.html">MT_RTT</a></li><li class="navelem"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html">Tunneled_check_collision</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_t___r_t_t_1_1_tunneled__check__collision-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MT_RTT::Tunneled_check_collision Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>In this object, the collision along a certain segment in the configurational space (i.e. a trajectory connecting two nodes) is checked considering a discrete set of equispaced samples, Section 2.2.3 of the documentation.  
 <a href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_problem__path__basic_8h_source.html">Problem_path_basic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MT_RTT::Tunneled_check_collision:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_m_t___r_t_t_1_1_tunneled__check__collision.png" usemap="#MT_5FRTT::Tunneled_5Fcheck_5Fcollision_map" alt=""/>
  <map id="MT_5FRTT::Tunneled_5Fcheck_5Fcollision_map" name="MT_5FRTT::Tunneled_5Fcheck_5Fcollision_map">
<area href="class_m_t___r_t_t_1_1_manipulator__path__handler.html" title="Interface for handling classical path planning problem of a single or a group of articulated fixed ro..." alt="MT_RTT::Manipulator_path_handler" shape="rect" coords="0,112,213,136"/>
<area href="class_m_t___r_t_t_1_1_node__factory__concrete.html" title="Each handler describing a real planning problem must be derived from this class." alt="MT_RTT::Node_factory_concrete" shape="rect" coords="0,56,213,80"/>
<area href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html" title="Interface for the class describing the particular planning problem to solve." alt="MT_RTT::Node::I_Node_factory" shape="rect" coords="0,0,213,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision_1_1_i___collision__checker.html">I_Collision_checker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object in charge of performing the collision check for a single generic configuration.  <a href="class_m_t___r_t_t_1_1_tunneled__check__collision_1_1_i___collision__checker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4161b9ff11d2000fa980cc70a13f4096"><td class="memItemLeft" align="right" valign="top"><a id="a4161b9ff11d2000fa980cc70a13f4096"></a>
<a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision_1_1_i___collision__checker.html">I_Collision_checker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#a4161b9ff11d2000fa980cc70a13f4096">Get_checker</a> ()</td></tr>
<tr class="memdesc:a4161b9ff11d2000fa980cc70a13f4096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the checker contained in this object. <br /></td></tr>
<tr class="separator:a4161b9ff11d2000fa980cc70a13f4096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dae2f0c3043de71480a173154fbaf46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#a8dae2f0c3043de71480a173154fbaf46">Tunneled_check_collision</a> (const float &amp;Gamma, const float &amp;steer_degree, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;Q_max, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;Q_min, std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision_1_1_i___collision__checker.html">I_Collision_checker</a> &gt; &amp;coll_checker)</td></tr>
<tr class="memdesc:a8dae2f0c3043de71480a173154fbaf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#a8dae2f0c3043de71480a173154fbaf46">More...</a><br /></td></tr>
<tr class="separator:a8dae2f0c3043de71480a173154fbaf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b2b335bf9c72f82902e20586de1e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#a0b6b2b335bf9c72f82902e20586de1e0">Tunneled_check_collision</a> (const float &amp;Gamma, const float &amp;steer_degree, const float &amp;q_max, const float &amp;q_min, const size_t &amp;dof, std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision_1_1_i___collision__checker.html">I_Collision_checker</a> &gt; &amp;coll_checker)</td></tr>
<tr class="memdesc:a0b6b2b335bf9c72f82902e20586de1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#a0b6b2b335bf9c72f82902e20586de1e0">More...</a><br /></td></tr>
<tr class="separator:a0b6b2b335bf9c72f82902e20586de1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa098f274f2ca2b2ec24ef2364dbe15a3"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; I_Node_factory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aa098f274f2ca2b2ec24ef2364dbe15a3">copy</a> ()</td></tr>
<tr class="memdesc:aa098f274f2ca2b2ec24ef2364dbe15a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for cloning this object: a deep copy must be implemented.  <a href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aa098f274f2ca2b2ec24ef2364dbe15a3">More...</a><br /></td></tr>
<tr class="separator:aa098f274f2ca2b2ec24ef2364dbe15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb241415099150bb9846aec2b1848385"><td class="memItemLeft" align="right" valign="top"><a id="aeb241415099150bb9846aec2b1848385"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aeb241415099150bb9846aec2b1848385">Steer</a> (float *cost_steered, float *steered_state, const float *start_state, const float *target_state, bool *trg_reached)</td></tr>
<tr class="memdesc:aeb241415099150bb9846aec2b1848385"><td class="mdescLeft">&#160;</td><td class="mdescRight">The steered pose lies in the segment connecting the nearest neighbour to the target node, at a distance (euclidean distance in the configurational space) which at most equal to steering degree. <br /></td></tr>
<tr class="separator:aeb241415099150bb9846aec2b1848385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa004c87d71129d0bbf14898e4544062e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aa004c87d71129d0bbf14898e4544062e">Cost_to_go_constraints</a> (float *result, const float *start_state, const float *ending_state)</td></tr>
<tr class="memdesc:aa004c87d71129d0bbf14898e4544062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collisions are checked only for some equispace intermediate poses lying on the segment connectin the starting state to the ending one. If a collision is detected, FLT_MAX is set as result, while in the opposite case the euclidean distance of the two poses is returned.  <a href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#aa004c87d71129d0bbf14898e4544062e">More...</a><br /></td></tr>
<tr class="separator:aa004c87d71129d0bbf14898e4544062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html">MT_RTT::Manipulator_path_handler</a></td></tr>
<tr class="memitem:aa1d0c75bb794a9b2ae872be9caf56216 inherit pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memItemLeft" align="right" valign="top"><a id="aa1d0c75bb794a9b2ae872be9caf56216"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#aa1d0c75bb794a9b2ae872be9caf56216">Random_node</a> (float *random_state)</td></tr>
<tr class="memdesc:aa1d0c75bb794a9b2ae872be9caf56216 inherit pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The hypercube delimited by the maximal and minimum possible joint excursions is sampled. <br /></td></tr>
<tr class="separator:aa1d0c75bb794a9b2ae872be9caf56216 inherit pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2cf22ed955fb79d13b2a4c15ab5dc1 inherit pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memItemLeft" align="right" valign="top"><a id="a7d2cf22ed955fb79d13b2a4c15ab5dc1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#a7d2cf22ed955fb79d13b2a4c15ab5dc1">Cost_to_go</a> (float *result, const float *start_state, const float *ending_state)</td></tr>
<tr class="memdesc:a7d2cf22ed955fb79d13b2a4c15ab5dc1 inherit pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost to go unconstrained is simply the euclidean distance (in the configurational space) between the two poses. <br /></td></tr>
<tr class="separator:a7d2cf22ed955fb79d13b2a4c15ab5dc1 inherit pub_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_t___r_t_t_1_1_node__factory__concrete.html">MT_RTT::Node_factory_concrete</a></td></tr>
<tr class="memitem:a64bcdb926aa1830448558e36b068fd20 inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memItemLeft" align="right" valign="top"><a id="a64bcdb926aa1830448558e36b068fd20"></a>
const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node__factory__concrete.html#a64bcdb926aa1830448558e36b068fd20">Get_State_size</a> () const</td></tr>
<tr class="memdesc:a64bcdb926aa1830448558e36b068fd20 inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cardinality of \mathcal{X}, Section 1.2.1 of the documentation, of the plannig problem handled by this object. <br /></td></tr>
<tr class="separator:a64bcdb926aa1830448558e36b068fd20 inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae282fb722e34a88c96f4d12b22d0befa inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memItemLeft" align="right" valign="top"><a id="ae282fb722e34a88c96f4d12b22d0befa"></a>
const float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node__factory__concrete.html#ae282fb722e34a88c96f4d12b22d0befa">Get_Gamma</a> () const</td></tr>
<tr class="memdesc:ae282fb722e34a88c96f4d12b22d0befa inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the \gamma parameter, Section 1.2.3 of the documentation, regulating the near set size, that RRT* versions must compute. <br /></td></tr>
<tr class="separator:ae282fb722e34a88c96f4d12b22d0befa inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bd45641307121cc4c943a70645a0b1 inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memItemLeft" align="right" valign="top"><a id="af3bd45641307121cc4c943a70645a0b1"></a>
const bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node__factory__concrete.html#af3bd45641307121cc4c943a70645a0b1">Get_symm_flag</a> () const</td></tr>
<tr class="memdesc:af3bd45641307121cc4c943a70645a0b1 inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true in case the planning problem handled by this object is symmetric, i.e. the cost to go from a node A to B is the same of the cost to go from B to A. <br /></td></tr>
<tr class="separator:af3bd45641307121cc4c943a70645a0b1 inherit pub_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">MT_RTT::Node::I_Node_factory</a></td></tr>
<tr class="memitem:ac400f20abadc07b9babc63eea56a7282 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top"><a id="ac400f20abadc07b9babc63eea56a7282"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>I_Node_factory</b> (const <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a> &amp;o)=delete</td></tr>
<tr class="separator:ac400f20abadc07b9babc63eea56a7282 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff670926bead9518c5b67295fe178fab inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top"><a id="aff670926bead9518c5b67295fe178fab"></a>
<a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">I_Node_factory</a> &amp;o)=delete</td></tr>
<tr class="separator:aff670926bead9518c5b67295fe178fab inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05f0d7d05d75033c8874a83a118d98a inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ac05f0d7d05d75033c8874a83a118d98a">Random_node</a> ()</td></tr>
<tr class="memdesc:ac05f0d7d05d75033c8874a83a118d98a inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a node having a state randomly sampled in the \mathcal{X} space, Section 1.2.1 of the documentation.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ac05f0d7d05d75033c8874a83a118d98a">More...</a><br /></td></tr>
<tr class="separator:ac05f0d7d05d75033c8874a83a118d98a inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032006307a2de0af57f1c02cd0c44df1 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a032006307a2de0af57f1c02cd0c44df1">Cost_to_go</a> (float *result, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *start, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *ending_node)</td></tr>
<tr class="memdesc:a032006307a2de0af57f1c02cd0c44df1 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the cost C(\tau), Section 1.2.3 of the documentation, of the trajectory \tau going from the starting node to the ending one, for two nodes not already connected.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a032006307a2de0af57f1c02cd0c44df1">More...</a><br /></td></tr>
<tr class="separator:a032006307a2de0af57f1c02cd0c44df1 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795eb5651df7246806d8a6188eb3809d inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a795eb5651df7246806d8a6188eb3809d">Cost_to_go_constraints</a> (float *result, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *start, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *trg)</td></tr>
<tr class="memdesc:a795eb5651df7246806d8a6188eb3809d inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the constrained cost of the trajectory going from the starting node to the ending one, for two nodes not already connected.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a795eb5651df7246806d8a6188eb3809d">More...</a><br /></td></tr>
<tr class="separator:a795eb5651df7246806d8a6188eb3809d inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e13935a7793bcff0939b43195a460 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a0f2e13935a7793bcff0939b43195a460">Steer</a> (<a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *start, const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> *trg, bool *trg_reached)</td></tr>
<tr class="memdesc:a0f2e13935a7793bcff0939b43195a460 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a steering operation, Section 1.2.1 of the documentation, from a staring node to a target one.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a0f2e13935a7793bcff0939b43195a460">More...</a><br /></td></tr>
<tr class="separator:a0f2e13935a7793bcff0939b43195a460 inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07c0cc5f12c85dfa5ca3717e829c3d inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a8f07c0cc5f12c85dfa5ca3717e829c3d">Clone_Node</a> (const <a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a> &amp;o)</td></tr>
<tr class="memdesc:a8f07c0cc5f12c85dfa5ca3717e829c3d inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a node with the same state and father of the node passed as input.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a8f07c0cc5f12c85dfa5ca3717e829c3d">More...</a><br /></td></tr>
<tr class="separator:a8f07c0cc5f12c85dfa5ca3717e829c3d inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3f419dc15cdedb4640d8818edc080c inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_t___r_t_t_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ade3f419dc15cdedb4640d8818edc080c">New_root</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;state)</td></tr>
<tr class="memdesc:ade3f419dc15cdedb4640d8818edc080c inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a new root for a tree.  <a href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ade3f419dc15cdedb4640d8818edc080c">More...</a><br /></td></tr>
<tr class="separator:ade3f419dc15cdedb4640d8818edc080c inherit pub_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html">MT_RTT::Manipulator_path_handler</a></td></tr>
<tr class="memitem:a730de164d0289870eb93cc5a173be578 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#a730de164d0289870eb93cc5a173be578">Manipulator_path_handler</a> (const float &amp;Gamma, const float *Q_max, const float *Q_min, const size_t &amp;Q_size)</td></tr>
<tr class="memdesc:a730de164d0289870eb93cc5a173be578 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#a730de164d0289870eb93cc5a173be578">More...</a><br /></td></tr>
<tr class="separator:a730de164d0289870eb93cc5a173be578 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4c8f8f0b4deb73fc9e5e65284d70c3 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#aef4c8f8f0b4deb73fc9e5e65284d70c3">Manipulator_path_handler</a> (const float &amp;Gamma, const std::vector&lt; float &gt; &amp;Q_max, const std::vector&lt; float &gt; &amp;Q_min)</td></tr>
<tr class="memdesc:aef4c8f8f0b4deb73fc9e5e65284d70c3 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#aef4c8f8f0b4deb73fc9e5e65284d70c3">More...</a><br /></td></tr>
<tr class="separator:aef4c8f8f0b4deb73fc9e5e65284d70c3 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a0275c528016b7de75540da425662 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memItemLeft" align="right" valign="top"><a id="ab63a0275c528016b7de75540da425662"></a>
const float *&#160;</td><td class="memItemRight" valign="bottom"><b>Get_max</b> () const</td></tr>
<tr class="separator:ab63a0275c528016b7de75540da425662 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd53e6a41a9a52a32bbb2f401779319 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memItemLeft" align="right" valign="top"><a id="a4dd53e6a41a9a52a32bbb2f401779319"></a>
const float *&#160;</td><td class="memItemRight" valign="bottom"><b>Get_min</b> () const</td></tr>
<tr class="separator:a4dd53e6a41a9a52a32bbb2f401779319 inherit pro_methods_class_m_t___r_t_t_1_1_manipulator__path__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_t___r_t_t_1_1_node__factory__concrete')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_t___r_t_t_1_1_node__factory__concrete.html">MT_RTT::Node_factory_concrete</a></td></tr>
<tr class="memitem:a88fbe5406772ddd902cc5e6844f3ecbf inherit pro_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_node__factory__concrete.html#a88fbe5406772ddd902cc5e6844f3ecbf">Node_factory_concrete</a> (const size_t &amp;X_size, const float &amp;gamma, const bool &amp;traj_symm_flag)</td></tr>
<tr class="memdesc:a88fbe5406772ddd902cc5e6844f3ecbf inherit pro_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of a new concrete problem.  <a href="class_m_t___r_t_t_1_1_node__factory__concrete.html#a88fbe5406772ddd902cc5e6844f3ecbf">More...</a><br /></td></tr>
<tr class="separator:a88fbe5406772ddd902cc5e6844f3ecbf inherit pro_methods_class_m_t___r_t_t_1_1_node__factory__concrete"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">MT_RTT::Node::I_Node_factory</a></td></tr>
<tr class="memitem:a5a83036622e3c4277ff6c57b18430b8f inherit pro_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memItemLeft" align="right" valign="top"><a id="a5a83036622e3c4277ff6c57b18430b8f"></a>
float *&#160;</td><td class="memItemRight" valign="bottom"><b>Alloc_state</b> ()</td></tr>
<tr class="separator:a5a83036622e3c4277ff6c57b18430b8f inherit pro_methods_class_m_t___r_t_t_1_1_node_1_1_i___node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>In this object, the collision along a certain segment in the configurational space (i.e. a trajectory connecting two nodes) is checked considering a discrete set of equispaced samples, Section 2.2.3 of the documentation. </p>
<p>An external object, in charge of performing the collision check must be passed and absorbed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8dae2f0c3043de71480a173154fbaf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dae2f0c3043de71480a173154fbaf46">&#9670;&nbsp;</a></span>Tunneled_check_collision() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MT_RTT::Tunneled_check_collision::Tunneled_check_collision </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>Gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>steer_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>Q_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>Q_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision_1_1_i___collision__checker.html">I_Collision_checker</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coll_checker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coll_checker</td><td>the object in charge of performing the collision check of a single pose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Gamma</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#a730de164d0289870eb93cc5a173be578" title="Constructor.">Manipulator_path_handler::Manipulator_path_handler</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steer_degree</td><td>a steered pose lies in the segment connecting the nearest neighbour to the target node, at a distance (euclidean distance in the configurational space) which is at most equal to the steer_degree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q_max</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#a730de164d0289870eb93cc5a173be578" title="Constructor.">Manipulator_path_handler::Manipulator_path_handler</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q_min</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_manipulator__path__handler.html#a730de164d0289870eb93cc5a173be578" title="Constructor.">Manipulator_path_handler::Manipulator_path_handler</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b6b2b335bf9c72f82902e20586de1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6b2b335bf9c72f82902e20586de1e0">&#9670;&nbsp;</a></span>Tunneled_check_collision() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MT_RTT::Tunneled_check_collision::Tunneled_check_collision </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>Gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>steer_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>q_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>q_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision_1_1_i___collision__checker.html">I_Collision_checker</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coll_checker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Similar to <a class="el" href="class_m_t___r_t_t_1_1_tunneled__check__collision.html#a8dae2f0c3043de71480a173154fbaf46" title="Constructor.">Tunneled_check_collision::Tunneled_check_collision(const float&amp; Gamma, const float&amp; steer_degree, const Node_State&amp; Q_max, const Node_State&amp; Q_min, std::unique_ptr&lt;I_Collision_checker&gt;&amp; coll_checker)</a>, but assuming that Q_max (and Q_min) have all the same values equal to q_max and has a size equal to dof. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa098f274f2ca2b2ec24ef2364dbe15a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa098f274f2ca2b2ec24ef2364dbe15a3">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;I_Node_factory&gt; MT_RTT::Tunneled_check_collision::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for cloning this object: a deep copy must be implemented. </p>
<p>This function is invoked by parallel planners for dispatching copies of this class to the other working threads. In this way, the threads must not be forced to synchronize for accessing the methods of an I_Node_factory. Therefore, when deriving your own factory describing your own problem, be carefull to avoid shallow copies and implement deep copies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>a clone of this object </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#ae5d9a5a09eee6dba95f2e671ac47677c">MT_RTT::Node::I_Node_factory</a>.</p>

</div>
</div>
<a id="aa004c87d71129d0bbf14898e4544062e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa004c87d71129d0bbf14898e4544062e">&#9670;&nbsp;</a></span>Cost_to_go_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::Tunneled_check_collision::Cost_to_go_constraints </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>start_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ending_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collisions are checked only for some equispace intermediate poses lying on the segment connectin the starting state to the ending one. If a collision is detected, FLT_MAX is set as result, while in the opposite case the euclidean distance of the two poses is returned. </p>
<p>The number of intermediate poses is chosen so as to realize that the intermediate poses are distant no more than the steering degree </p>

<p>Implements <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a333bb3df2390834f118bda25eccc44ee">MT_RTT::Node::I_Node_factory</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Header/<a class="el" href="_problem__path__basic_8h_source.html">Problem_path_basic.h</a></li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Problem_path_basic.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
