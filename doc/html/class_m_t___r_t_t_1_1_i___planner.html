<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MT_RRT, the general purpose multi threading library for RRT.: MT_RTT::I_Planner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MT_RRT, the general purpose multi threading library for RRT.
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_m_t___r_t_t.html">MT_RTT</a></li><li class="navelem"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_m_t___r_t_t_1_1_i___planner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MT_RTT::I_Planner Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for a planner.  
 <a href="class_m_t___r_t_t_1_1_i___planner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_planner_8h_source.html">Planner.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MT_RTT::I_Planner:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_m_t___r_t_t_1_1_i___planner.png" usemap="#MT_5FRTT::I_5FPlanner_map" alt=""/>
  <map id="MT_5FRTT::I_5FPlanner_map" name="MT_5FRTT::I_5FPlanner_map">
<area href="class_m_t___r_t_t_1_1_i___planner___m_t.html" title="This class contains common functionalities that every multi-threaded planner may use." alt="MT_RTT::I_Planner_MT" shape="rect" coords="306,56,500,80"/>
<area href="class_m_t___r_t_t_1_1_planner__canonical.html" alt="MT_RTT::Planner_canonical" shape="rect" coords="510,56,704,80"/>
<area href="class_m_t___r_t_t_1_1_planner__copied__parall.html" alt="MT_RTT::Planner_copied_parall" shape="rect" coords="0,112,194,136"/>
<area href="class_m_t___r_t_t_1_1_planner__multi__agents.html" alt="MT_RTT::Planner_multi_agents" shape="rect" coords="204,112,398,136"/>
<area href="class_m_t___r_t_t_1_1_planner__query__parall.html" alt="MT_RTT::Planner_query_parall" shape="rect" coords="408,112,602,136"/>
<area href="class_m_t___r_t_t_1_1_planner__shared__parall.html" alt="MT_RTT::Planner_shared_parall" shape="rect" coords="612,112,806,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_t___r_t_t_1_1_i___planner_1_1____last__solution__info.html">__last_solution_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af763d55899da1a7b79120bc4e9511edd"><td class="memItemLeft" align="right" valign="top"><a id="af763d55899da1a7b79120bc4e9511edd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>I_Planner</b> (const <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &amp;)=delete</td></tr>
<tr class="separator:af763d55899da1a7b79120bc4e9511edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5b0e212d669c0aa9f8042a543ebec2"><td class="memItemLeft" align="right" valign="top"><a id="a8e5b0e212d669c0aa9f8042a543ebec2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &amp;)=delete</td></tr>
<tr class="separator:a8e5b0e212d669c0aa9f8042a543ebec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ac58185263c3c83e6ccb9c4c164ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#af8ac58185263c3c83e6ccb9c4c164ab3">Cumulate_solutions</a> ()</td></tr>
<tr class="memdesc:af8ac58185263c3c83e6ccb9c4c164ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to enable the cumulation of the solution also for non RRT* versions of the planner.  <a href="class_m_t___r_t_t_1_1_i___planner.html#af8ac58185263c3c83e6ccb9c4c164ab3">More...</a><br /></td></tr>
<tr class="separator:af8ac58185263c3c83e6ccb9c4c164ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab56690d073c42f8301d8665a235d12e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#aab56690d073c42f8301d8665a235d12e">RRT_basic</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;start, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;end)</td></tr>
<tr class="memdesc:aab56690d073c42f8301d8665a235d12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to solve the problem by executing the basic single tree RRT version (Section 1.2.1 and the Sections contained in Chapter 3 of the documentation) of the solver represented by this object, step C of the pipeline presented in Section 1.3 of the documentation.  <a href="class_m_t___r_t_t_1_1_i___planner.html#aab56690d073c42f8301d8665a235d12e">More...</a><br /></td></tr>
<tr class="separator:aab56690d073c42f8301d8665a235d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158cadc5d15c1776c0d0c82e55bf2006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a158cadc5d15c1776c0d0c82e55bf2006">RRT_bidirectional</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;start, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;end)</td></tr>
<tr class="memdesc:a158cadc5d15c1776c0d0c82e55bf2006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to solve the problem by executing the bidirectional RRT version (Section 1.2.2 and the Sections contained in Chapter 3 of the documentation) of the solver represented by this object, step C of the pipeline presented in Section 1.3 of the documentation.  <a href="class_m_t___r_t_t_1_1_i___planner.html#a158cadc5d15c1776c0d0c82e55bf2006">More...</a><br /></td></tr>
<tr class="separator:a158cadc5d15c1776c0d0c82e55bf2006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bfb3101b8862d5efd20d3536123a40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a89bfb3101b8862d5efd20d3536123a40">RRT_star</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;start, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;end)</td></tr>
<tr class="memdesc:a89bfb3101b8862d5efd20d3536123a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to solve the problem by executing the RRT* version (Section 1.2.3 and the Sections contained in Chapter 3 of the documentation) of the solver represented by this object, step C of the pipeline presented in Section 1.3 of the documentation.  <a href="class_m_t___r_t_t_1_1_i___planner.html#a89bfb3101b8862d5efd20d3536123a40">More...</a><br /></td></tr>
<tr class="separator:a89bfb3101b8862d5efd20d3536123a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23808226f2d9f366adb8189edad1c4f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a23808226f2d9f366adb8189edad1c4f6">Get_Iteration_done</a> ()</td></tr>
<tr class="memdesc:a23808226f2d9f366adb8189edad1c4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the number of iterations performed by the solver for trying to solve the last specified planning problem.  <a href="class_m_t___r_t_t_1_1_i___planner.html#a23808226f2d9f366adb8189edad1c4f6">More...</a><br /></td></tr>
<tr class="separator:a23808226f2d9f366adb8189edad1c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f0165b1163b4ddac62624d4d91626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a1c7f0165b1163b4ddac62624d4d91626">Get_solution</a> (std::list&lt; <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &gt; *result)</td></tr>
<tr class="memdesc:a1c7f0165b1163b4ddac62624d4d91626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the number of iterations performed by the solver for trying to solve the last specified planning problem, step D.1 of the pipeline presented in Section 1.3 of the documentation.  <a href="class_m_t___r_t_t_1_1_i___planner.html#a1c7f0165b1163b4ddac62624d4d91626">More...</a><br /></td></tr>
<tr class="separator:a1c7f0165b1163b4ddac62624d4d91626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f590b600162317fc898fed30101fbe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a28f590b600162317fc898fed30101fbe">Get_Trees_as_JSON</a> ()</td></tr>
<tr class="memdesc:a28f590b600162317fc898fed30101fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a json structure describing the searching trees computed when solving the last specified planning problem, step D.2 of the pipeline presented in Section 1.3 of the documentation.  <a href="class_m_t___r_t_t_1_1_i___planner.html#a28f590b600162317fc898fed30101fbe">More...</a><br /></td></tr>
<tr class="separator:a28f590b600162317fc898fed30101fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a51130bbea140e3e350e95d6511078e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a7a51130bbea140e3e350e95d6511078e">Get_Solution_as_JSON</a> ()</td></tr>
<tr class="memdesc:a7a51130bbea140e3e350e95d6511078e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to the passed string a json structure describing the sequence of states representing the last solution found, step D.2 of the pipeline presented in Section 1.3 of the documentation.  <a href="class_m_t___r_t_t_1_1_i___planner.html#a7a51130bbea140e3e350e95d6511078e">More...</a><br /></td></tr>
<tr class="separator:a7a51130bbea140e3e350e95d6511078e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab615cc83b032590cc05310e9b5ba05c8"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8">Get_canonical</a> (const float &amp;det_coeff, const size_t &amp;max_iter, <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *handler)</td></tr>
<tr class="memdesc:ab615cc83b032590cc05310e9b5ba05c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections 1.2.1, 1.2.2 and 1.2.3 of the documentation).  <a href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8">More...</a><br /></td></tr>
<tr class="separator:ab615cc83b032590cc05310e9b5ba05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c102fc49f9ed735e87e36bf34e628b3"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a0c102fc49f9ed735e87e36bf34e628b3">Get_query___parall</a> (const float &amp;det_coeff, const size_t &amp;max_iter, <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *handler, const size_t &amp;N_threads=0)</td></tr>
<tr class="memdesc:a0c102fc49f9ed735e87e36bf34e628b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solver for which the query operations are parallelized (Section 3.0.1 of the documentation).  <a href="class_m_t___r_t_t_1_1_i___planner.html#a0c102fc49f9ed735e87e36bf34e628b3">More...</a><br /></td></tr>
<tr class="separator:a0c102fc49f9ed735e87e36bf34e628b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eed3f1c331c43f773cefcb3f53c827b"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a8eed3f1c331c43f773cefcb3f53c827b">Get_shared__parall</a> (const float &amp;det_coeff, const size_t &amp;max_iter, <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *handler, const size_t &amp;N_threads=0)</td></tr>
<tr class="memdesc:a8eed3f1c331c43f773cefcb3f53c827b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solver for which many threads synchronize to expand a common tree (Section 3.0.2 of the documentation).  <a href="class_m_t___r_t_t_1_1_i___planner.html#a8eed3f1c331c43f773cefcb3f53c827b">More...</a><br /></td></tr>
<tr class="separator:a8eed3f1c331c43f773cefcb3f53c827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbd5c6689d87795148fd8bca0a1b3a8"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a7cbd5c6689d87795148fd8bca0a1b3a8">Get_copied__parall</a> (const float &amp;det_coeff, const size_t &amp;max_iter, <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *handler, const size_t &amp;N_threads=0, const float &amp;reallignement_percentage=0.1f)</td></tr>
<tr class="memdesc:a7cbd5c6689d87795148fd8bca0a1b3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solver for which many threads expands its own copy of the searching tree (Section 3.0.3 of the documentation).  <a href="class_m_t___r_t_t_1_1_i___planner.html#a7cbd5c6689d87795148fd8bca0a1b3a8">More...</a><br /></td></tr>
<tr class="separator:a7cbd5c6689d87795148fd8bca0a1b3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b51d8dcc6302db614b57d458c4cfbcc"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a9b51d8dcc6302db614b57d458c4cfbcc">Get_multi_ag_parall</a> (const float &amp;det_coeff, const size_t &amp;max_iter, <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *handler, const size_t &amp;N_threads=0, const float &amp;reallignement_percentage=0.1f)</td></tr>
<tr class="memdesc:a9b51d8dcc6302db614b57d458c4cfbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solver implementing the multi agents version of the RRT algorithm (Section 3.0.4 of the documentation).  <a href="class_m_t___r_t_t_1_1_i___planner.html#a9b51d8dcc6302db614b57d458c4cfbcc">More...</a><br /></td></tr>
<tr class="separator:a9b51d8dcc6302db614b57d458c4cfbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3104dc11e3ebd904ac11653ac48b09ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a3104dc11e3ebd904ac11653ac48b09ef">I_Planner</a> (const float &amp;det_coeff, const size_t &amp;max_iter, <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *handler)</td></tr>
<tr class="memdesc:a3104dc11e3ebd904ac11653ac48b09ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_m_t___r_t_t_1_1_i___planner.html#a3104dc11e3ebd904ac11653ac48b09ef">More...</a><br /></td></tr>
<tr class="separator:a3104dc11e3ebd904ac11653ac48b09ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb09ceb289d37bceb1a8314aa9094d0"><td class="memItemLeft" align="right" valign="top"><a id="a5cb09ceb289d37bceb1a8314aa9094d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a5cb09ceb289d37bceb1a8314aa9094d0">_RRT_basic</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;start, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;end)=0</td></tr>
<tr class="memdesc:a5cb09ceb289d37bceb1a8314aa9094d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the method overrided by all the derived planner for performing an RRT search <br /></td></tr>
<tr class="separator:a5cb09ceb289d37bceb1a8314aa9094d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab958f989d7559bc9c8d84afa83d7275d"><td class="memItemLeft" align="right" valign="top"><a id="ab958f989d7559bc9c8d84afa83d7275d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab958f989d7559bc9c8d84afa83d7275d">_RRT_bidirectional</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;start, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;end)=0</td></tr>
<tr class="memdesc:ab958f989d7559bc9c8d84afa83d7275d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the method overrided by all the derived planner for performing a bidirectionl search <br /></td></tr>
<tr class="separator:ab958f989d7559bc9c8d84afa83d7275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325cb2d6bd3183c823839c180a477357"><td class="memItemLeft" align="right" valign="top"><a id="a325cb2d6bd3183c823839c180a477357"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a325cb2d6bd3183c823839c180a477357">_RRT_star</a> (const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;start, const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;end)=0</td></tr>
<tr class="memdesc:a325cb2d6bd3183c823839c180a477357"><td class="mdescLeft">&#160;</td><td class="mdescRight">the method overrided by all the derived planner for performing an RRT* search <br /></td></tr>
<tr class="separator:a325cb2d6bd3183c823839c180a477357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4eef5bfd568a40684ccfa3915034fab"><td class="memItemLeft" align="right" valign="top"><a id="aa4eef5bfd568a40684ccfa3915034fab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Set_Solution</b> (const <a class="el" href="struct_m_t___r_t_t_1_1_i___planner_1_1____last__solution__info.html">__last_solution_info</a> &amp;last_sol)</td></tr>
<tr class="separator:aa4eef5bfd568a40684ccfa3915034fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0cdef3802becf2aebb4e72626973315c"><td class="memItemLeft" align="right" valign="top"><a id="a0cdef3802becf2aebb4e72626973315c"></a>
<a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Handler</b></td></tr>
<tr class="separator:a0cdef3802becf2aebb4e72626973315c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5242d707c2ba2d261781d253cf8e2ae0"><td class="memItemLeft" align="right" valign="top"><a id="a5242d707c2ba2d261781d253cf8e2ae0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>Deterministic_coefficient</b></td></tr>
<tr class="separator:a5242d707c2ba2d261781d253cf8e2ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f6cb6969319498c337cdca6fa2764c"><td class="memItemLeft" align="right" valign="top"><a id="a05f6cb6969319498c337cdca6fa2764c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>Iterations_Max</b></td></tr>
<tr class="separator:a05f6cb6969319498c337cdca6fa2764c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828cc2efe2a82af2f40be8bfc0a2c6be"><td class="memItemLeft" align="right" valign="top"><a id="a828cc2efe2a82af2f40be8bfc0a2c6be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Cumulate_sol</b></td></tr>
<tr class="separator:a828cc2efe2a82af2f40be8bfc0a2c6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for a planner. </p>
<p>For solving a planning problem you must first build the solver, using <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a>, <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a0c102fc49f9ed735e87e36bf34e628b3" title="Get the solver for which the query operations are parallelized (Section 3.0.1 of the documentation).">I_Planner::Get_query___parall</a>, <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a8eed3f1c331c43f773cefcb3f53c827b" title="Get the solver for which many threads synchronize to expand a common tree (Section 3....">I_Planner::Get_shared__parall</a>, <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a7cbd5c6689d87795148fd8bca0a1b3a8" title="Get the solver for which many threads expands its own copy of the searching tree (Section 3....">I_Planner::Get_copied__parall</a> or <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a9b51d8dcc6302db614b57d458c4cfbcc" title="Get the solver implementing the multi agents version of the RRT algorithm (Section 3....">I_Planner::Get_multi_ag_parall</a>. Then you can call <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#aab56690d073c42f8301d8665a235d12e" title="Tries to solve the problem by executing the basic single tree RRT version (Section 1....">I_Planner::RRT_basic</a>, <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a158cadc5d15c1776c0d0c82e55bf2006" title="Tries to solve the problem by executing the bidirectional RRT version (Section 1.2....">I_Planner::RRT_bidirectional</a> or <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a89bfb3101b8862d5efd20d3536123a40" title="Tries to solve the problem by executing the RRT* version (Section 1.2.3 and the Sections contained in...">I_Planner::RRT_star</a> of the created solver, passing the starting and ending states of the problem that you want to solve. Finally, you can use <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a1c7f0165b1163b4ddac62624d4d91626" title="Access the number of iterations performed by the solver for trying to solve the last specified planni...">I_Planner::Get_solution</a> to get the obtained solution, i.e. the chain of states connecting the staring and the ending nodes, compliant with the constraints. In case a solution was not found, an empty path is returned. Another planning process can be invoked using the same object. In this case, the info about the last planning are detroyed and replaced with the new one. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3104dc11e3ebd904ac11653ac48b09ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3104dc11e3ebd904ac11653ac48b09ef">&#9670;&nbsp;</a></span>I_Planner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MT_RTT::I_Planner::I_Planner </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>det_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">det_coeff</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af8ac58185263c3c83e6ccb9c4c164ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ac58185263c3c83e6ccb9c4c164ab3">&#9670;&nbsp;</a></span>Cumulate_solutions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::I_Planner::Cumulate_solutions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this method to enable the cumulation of the solution also for non RRT* versions of the planner. </p>
<p>In case the cumulation is enabled, the search is not arrested when a first solution is found, but is kept active till the maximum number of iterations is reached. All the solutions found are stored and the best one is selected at the end. This solution will be the one externally accesible. </p>

</div>
</div>
<a id="ab615cc83b032590cc05310e9b5ba05c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab615cc83b032590cc05310e9b5ba05c8">&#9670;&nbsp;</a></span>Get_canonical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt; MT_RTT::I_Planner::Get_canonical </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>det_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections 1.2.1, 1.2.2 and 1.2.3 of the documentation). </p>
<p>The creation of this kind of solver addresses step B of the pipeline presented in Section 1.3 of the documentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the solver to use later </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">det_coeff</td><td>the percentage of times for which a deterministic extension must be tried to get a solution (the parameter \sigma of the algorithms exposed in Sections 1.2.1, 1.2.2 and 1.2.3 of the documentation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>the maximum number of iterations to consider when soving the planning problems </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>the object describing the planning problem to solve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cbd5c6689d87795148fd8bca0a1b3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbd5c6689d87795148fd8bca0a1b3a8">&#9670;&nbsp;</a></span>Get_copied__parall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt; MT_RTT::I_Planner::Get_copied__parall </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>det_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N_threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>reallignement_percentage</em> = <code>0.1f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the solver for which many threads expands its own copy of the searching tree (Section 3.0.3 of the documentation). </p>
<p>The creation of this kind of solver addresses step B of the pipeline presented in Section 1.3 of the documentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the solver to use later </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">det_coeff</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_threads</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a0c102fc49f9ed735e87e36bf34e628b3" title="Get the solver for which the query operations are parallelized (Section 3.0.1 of the documentation).">I_Planner::Get_query___parall</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reallignement_percentage</td><td>the size of the explorative batches (percentage w.r.t. max_iter), see Section 3.0.3 of the documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23808226f2d9f366adb8189edad1c4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23808226f2d9f366adb8189edad1c4f6">&#9670;&nbsp;</a></span>Get_Iteration_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MT_RTT::I_Planner::Get_Iteration_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the number of iterations performed by the solver for trying to solve the last specified planning problem. </p>
<p>Result is 0 in case no problems were solved at the time of invoking this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the number of iterations done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b51d8dcc6302db614b57d458c4cfbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b51d8dcc6302db614b57d458c4cfbcc">&#9670;&nbsp;</a></span>Get_multi_ag_parall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt; MT_RTT::I_Planner::Get_multi_ag_parall </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>det_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N_threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>reallignement_percentage</em> = <code>0.1f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the solver implementing the multi agents version of the RRT algorithm (Section 3.0.4 of the documentation). </p>
<p>The creation of this kind of solver addresses step B of the pipeline presented in Section 1.3 of the documentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the solver to use later </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">det_coeff</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_threads</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a0c102fc49f9ed735e87e36bf34e628b3" title="Get the solver for which the query operations are parallelized (Section 3.0.1 of the documentation).">I_Planner::Get_query___parall</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reallignement_percentage</td><td>similar meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a7cbd5c6689d87795148fd8bca0a1b3a8" title="Get the solver for which many threads expands its own copy of the searching tree (Section 3....">I_Planner::Get_copied__parall</a>, see Section 3.0.4 of the documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c102fc49f9ed735e87e36bf34e628b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c102fc49f9ed735e87e36bf34e628b3">&#9670;&nbsp;</a></span>Get_query___parall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt; MT_RTT::I_Planner::Get_query___parall </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>det_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the solver for which the query operations are parallelized (Section 3.0.1 of the documentation). </p>
<p>The creation of this kind of solver addresses step B of the pipeline presented in Section 1.3 of the documentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the solver to use later </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">det_coeff</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_threads</td><td>the number of threads to use. When passing 0, the maximal number admitted by this machine is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eed3f1c331c43f773cefcb3f53c827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eed3f1c331c43f773cefcb3f53c827b">&#9670;&nbsp;</a></span>Get_shared__parall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html">I_Planner</a> &gt; MT_RTT::I_Planner::Get_shared__parall </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>det_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html">Node::I_Node_factory</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the solver for which many threads synchronize to expand a common tree (Section 3.0.2 of the documentation). </p>
<p>The creation of this kind of solver addresses step B of the pipeline presented in Section 1.3 of the documentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the solver to use later </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">det_coeff</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#ab615cc83b032590cc05310e9b5ba05c8" title="Get a canonical solver implementing the standard non parallel versions of the RRT algorith (Sections ...">I_Planner::Get_canonical</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_threads</td><td>same meaning as in <a class="el" href="class_m_t___r_t_t_1_1_i___planner.html#a0c102fc49f9ed735e87e36bf34e628b3" title="Get the solver for which the query operations are parallelized (Section 3.0.1 of the documentation).">I_Planner::Get_query___parall</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c7f0165b1163b4ddac62624d4d91626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7f0165b1163b4ddac62624d4d91626">&#9670;&nbsp;</a></span>Get_solution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::I_Planner::Get_solution </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &gt; *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the number of iterations performed by the solver for trying to solve the last specified planning problem, step D.1 of the pipeline presented in Section 1.3 of the documentation. </p>
<p>An empty list is returned in case the solution was not found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>the number of iterations done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a51130bbea140e3e350e95d6511078e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a51130bbea140e3e350e95d6511078e">&#9670;&nbsp;</a></span>Get_Solution_as_JSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string MT_RTT::I_Planner::Get_Solution_as_JSON </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append to the passed string a json structure describing the sequence of states representing the last solution found, step D.2 of the pipeline presented in Section 1.3 of the documentation. </p>
<p>An empty structure is returned in case no problems were solved at the time of invoking this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>a json structure with the waypoints representing the solution (move is internally called when returning the result). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f590b600162317fc898fed30101fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f590b600162317fc898fed30101fbe">&#9670;&nbsp;</a></span>Get_Trees_as_JSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string MT_RTT::I_Planner::Get_Trees_as_JSON </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a json structure describing the searching trees computed when solving the last specified planning problem, step D.2 of the pipeline presented in Section 1.3 of the documentation. </p>
<p>An empty structure is returned in case no problems were solved at the time of invoking this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">return</td><td>a json structure describing the searching tree computed to solve the last problem (move is internally called when returning the result). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab56690d073c42f8301d8665a235d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab56690d073c42f8301d8665a235d12e">&#9670;&nbsp;</a></span>RRT_basic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::I_Planner::RRT_basic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to solve the problem by executing the basic single tree RRT version (Section 1.2.1 and the Sections contained in Chapter 3 of the documentation) of the solver represented by this object, step C of the pipeline presented in Section 1.3 of the documentation. </p>
<p>The solution found is internally stored, as well as the computed searching tree. The data about the solutions of any previous problem solved are deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>the staring state of the problem to solve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the ending state of the problem to solve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a158cadc5d15c1776c0d0c82e55bf2006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158cadc5d15c1776c0d0c82e55bf2006">&#9670;&nbsp;</a></span>RRT_bidirectional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::I_Planner::RRT_bidirectional </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to solve the problem by executing the bidirectional RRT version (Section 1.2.2 and the Sections contained in Chapter 3 of the documentation) of the solver represented by this object, step C of the pipeline presented in Section 1.3 of the documentation. </p>
<p>The solution found is internally stored, as well as the computed searching trees. The data about the solutions of any previous problem solved are deleted. This planning strategy cannot be adopted for non symmetric problem, see also <a class="el" href="class_m_t___r_t_t_1_1_node_1_1_i___node__factory.html#a6b515a5b23df01e30a59a940de6fffe5" title="Returns true in case the planning problem handled by this object is symmetric, i.e....">Node::I_Node_factory::Get_symm_flag</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>the staring state of the problem to solve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the ending state of the problem to solve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89bfb3101b8862d5efd20d3536123a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bfb3101b8862d5efd20d3536123a40">&#9670;&nbsp;</a></span>RRT_star()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MT_RTT::I_Planner::RRT_star </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t___r_t_t_1_1_node___state.html">Node_State</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to solve the problem by executing the RRT* version (Section 1.2.3 and the Sections contained in Chapter 3 of the documentation) of the solver represented by this object, step C of the pipeline presented in Section 1.3 of the documentation. </p>
<p>The solution found is internally stored, as well as the computed searching trees. The data about the solutions of any previous problem solved are deleted. When invoking this function the cumulation of the solutions is aitomatically enabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>the staring state of the problem to solve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>the ending state of the problem to solve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Header/<a class="el" href="_planner_8h_source.html">Planner.h</a></li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Planner.cpp</li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Planner_canonical.cpp</li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Planner_copied_parall.cpp</li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Planner_multi_agents.cpp</li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Planner_query_parall.cpp</li>
<li>C:/Users/andre/Desktop/MT_RRT/MT_RRT/Source/Planner_shared_parall.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
